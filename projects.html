<html>
	<script>
  BLOCK_WIDTH  = 20;
  BLOCK_HEIGHT = 20;
  COLOR_VALUES = [150, 250, 50, 100, 0]

	var main = function() {
    initCanvas();
    initPortrait();
    blocks = initBlocksObject();
    window.onresize = resizeCanvas;
	}


  var initCanvas = function() {
		canvas = document.getElementById('bigCanvas');
		ctx = canvas.getContext('2d');
    resizeCanvas();
  }

  var initPortrait = function() {
    img = new Image;
    img.src = 'self_portrait.jpg';
    img.onload = resizePortrait;
  }

  var initBlocksObject = function() {
    function Blocks(ctx) {
      // This is the Blocks constructor function
      this.pixels = [];
      this.ctx = ctx;
      this.numCols = Math.ceil(ctx.canvas.width  / BLOCK_WIDTH);
      this.numRows = Math.ceil(ctx.canvas.height  / BLOCK_HEIGHT);
      this.fillPixels = function() {
        for (var row = 0; row <= this.numRows; row++) {
          for (var col = 0; col <= this.numCols; col++) {
            (row * col % 2 == 0) ? this.pixels.push("#FFFFFF") : this.pixels.push("#000000");
          }
        }
      }

     this.eachBlock = function(callback) {
       for (var row = 0; row <= this.numRows; row++) {
         for (var col = 0; col <= this.numCols; col++) {
           callback.call(this, row, col)
         }
       }
     }

      this.draw = function() {
        var pixCount = 0;
        this.eachBlock(function(row, col) {
          ctx.fillStyle = this.pixels[pixCount];
          ctx.fillRect(col * BLOCK_WIDTH, row * BLOCK_WIDTH, BLOCK_WIDTH, BLOCK_WIDTH);
          pixCount += 1;
        });
      }
    }
    return new Blocks(ctx);
  }

  var resizePortrait = function() {
    // Turn off smoothing to get pixelated effect
    ctx.mozImageSmoothingEnabled = false;
    ctx.webkitImageSmoothingEnabled = false;
    ctx.imageSmoothingEnabled = false;
    // save aspect ratio
    img.ratio = img.width / img.height
    // resize original image to fit viewport
    ctx.drawImage(img, 0, 0, img.ratio * canvas.height, canvas.height)
    // take that image and calc total pixels
    sizedImgData = ctx.getImageData(0, 0, img.ratio * canvas.height, canvas.height)
    // Divide total real pixels by area of a single "new" pixel
    totalPixels = (sizedImgData.width * sizedImgData.height) / (BLOCK_WIDTH * BLOCK_HEIGHT)
    // find height of new image with fewer  pixels
    height_sq = totalPixels / img.ratio
    tiny_h = Math.round(Math.sqrt(height_sq))
    // find width of new image with fewer pixels
    tiny_w = Math.round(tiny_h * img.ratio)
    // Draw tiny image
    ctx.drawImage(img, 0, 0, tiny_w, tiny_h)
    // get tiny image data and convert to grayscale
    tinyData = ctx.getImageData(0, 0, tiny_w, tiny_h);
    console.log(tinyData.data);
    convertToGrayscale(tinyData.data);
    // redraw gray version on canvas
    ctx.putImageData(tinyData, 0, 0)
    // blow up tiny image to draw final pixelated image
    pixelatedImgWidth = canvas.height * img.ratio
    ctx.drawImage(canvas, 0, 0, tiny_w, tiny_h, imageMargin(pixelatedImgWidth), 0, pixelatedImgWidth, canvas.height)
    //ctx.clearRect(0,0, img.ratio * canvas.height, canvas.height);
    window.requestAnimationFrame(drawPattern);
  }

  var convertToGrayscale = function(data) {
    // takes in ImageData.data and converts it to gray
    for(var i = 0; i < data.length; i += 4) {
      var brightness = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];
      // red
      data[i] = brightness;
      // green
      data[i + 1] = brightness;
      // blue
      data[i + 2] = brightness;
    }
  }
  
  var imageMargin = function(img_width) {
    return (canvas.width - img_width) / 2
  }

  var resizeCanvas = function() {
    setCanvasSize();
    //blackOutCanvas();
  }

  var blackOutCanvas = function() {
    ctx.fillRect(0,0,canvas.width, canvas.height); // initialize with black
  }

  var setCanvasSize = function() {
    canvas.width  = window.innerWidth
    canvas.height = window.innerHeight
  }

  var randColor   = function() {
    return COLOR_VALUES[Math.floor(Math.random() * COLOR_VALUES.length)]
  }

  var drawPattern = function(step) {
    var numCols = Math.ceil(ctx.canvas.width  / BLOCK_WIDTH);
    var numRows = Math.ceil(ctx.canvas.height / BLOCK_HEIGHT);
 //   for (var i = 0; i <= tinyData.data.length; i += 4) {
 //     var gray = tinyData.data[i]
 //     ctx.fillStyle = "rgb(" + gray + "," + gray + "," + gray + ")";
 //     ctx.fillRect( Math.round(count % tiny_w) * BLOCK_WIDTH, Math.floor(count / tiny_w) * BLOCK_HEIGHT, BLOCK_WIDTH, BLOCK_HEIGHT);
 //     console.log(Math.floor(count % tiny_w))
 //     count += 1;
 //   }
    var pixCount = 0
    for(var i=0; i <= numRows; i++) {
      for(var j=0; j <= numCols; j++) {
          var index = (pixCount * 4);
          var gray = tinyData.data[index]
          ctx.fillStyle = "rgb(" + gray + "," + gray + "," + gray + ")";
          ctx.fillRect( Math.round(pixCount % tiny_w) * BLOCK_WIDTH, Math.floor(pixCount / tiny_w) * BLOCK_HEIGHT, BLOCK_WIDTH, BLOCK_HEIGHT);
          pixCount += 1;
        if (Math.random() > 0.993) {
          ctx.fillStyle = "rgb(" + randColor() + "," + randColor() + "," + randColor() + ")";
          ctx.fillRect(j * BLOCK_WIDTH, i * BLOCK_WIDTH, BLOCK_WIDTH, BLOCK_WIDTH);
        }
      }
    }
    //setTimeout(requestNextFrame, 40);

  }

  var requestNextFrame = function() {
    window.requestAnimationFrame(drawPattern);
  }

	</script>
    <style type="text/css">
      canvas { 
        position: absolute;
        top: 0;
        left: 0;
        z-index: -1;
      }

      #text-container {
        padding: 50px;
        opacity: 0.9;
        background-color: black;
        color: white;
      }
    </style>
	<body onload="main();">
		<canvas id="bigCanvas"></canvas>
	</body>

</html>
